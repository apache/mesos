diff --git a/src/Makefile.am b/src/Makefile.am
index e698927..236d41a 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -719,6 +719,7 @@ if OS_LINUX
   libmesos_no_3rdparty_la_SOURCES += slave/containerizer/isolators/filesystem/shared.cpp
   libmesos_no_3rdparty_la_SOURCES += slave/containerizer/linux_launcher.cpp
   libmesos_no_3rdparty_la_SOURCES += slave/containerizer/provisioner/backends/bind.cpp
+  libmesos_no_3rdparty_la_SOURCES += slave/containerizer/provisioner/backends/overlay.cpp
 else
   EXTRA_DIST += linux/cgroups.cpp
   EXTRA_DIST += linux/fs.cpp
@@ -842,6 +843,7 @@ libmesos_no_3rdparty_la_SOURCES +=					\
 	slave/containerizer/provisioner/backend.hpp			\
 	slave/containerizer/provisioner/backends/bind.hpp		\
 	slave/containerizer/provisioner/backends/copy.hpp		\
+	slave/containerizer/provisioner/backends/overlay.hpp		\
 	slave/containerizer/provisioner/docker/local_puller.hpp		\
 	slave/containerizer/provisioner/docker/message.hpp		\
 	slave/containerizer/provisioner/docker/metadata_manager.hpp	\
diff --git a/src/slave/containerizer/provisioner/backend.cpp b/src/slave/containerizer/provisioner/backend.cpp
index b5d9670..4ed8963 100644
--- a/src/slave/containerizer/provisioner/backend.cpp
+++ b/src/slave/containerizer/provisioner/backend.cpp
@@ -24,6 +24,7 @@
 
 #include "slave/containerizer/provisioner/backends/bind.hpp"
 #include "slave/containerizer/provisioner/backends/copy.hpp"
+#include "slave/containerizer/provisioner/backends/overlay.hpp"
 
 using namespace process;
 
@@ -39,6 +40,7 @@ hashmap<string, Owned<Backend>> Backend::create(const Flags& flags)
 
 #ifdef __linux__
   creators.put("bind", &BindBackend::create);
+  creators.put("overlay", &OverlayBackend::create);
 #endif // __linux__
   creators.put("copy", &CopyBackend::create);
 
diff --git a/src/slave/containerizer/provisioner/backends/overlay.cpp b/src/slave/containerizer/provisioner/backends/overlay.cpp
new file mode 100644
index 0000000..c96d38c
--- /dev/null
+++ b/src/slave/containerizer/provisioner/backends/overlay.cpp
@@ -0,0 +1,181 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <process/dispatch.hpp>
+#include <process/process.hpp>
+
+#include <stout/foreach.hpp>
+#include <stout/os.hpp>
+
+#include "linux/fs.hpp"
+
+#include "slave/containerizer/provisioner/backends/overlay.hpp"
+
+using namespace process;
+
+using std::string;
+using std::vector;
+
+namespace mesos {
+namespace internal {
+namespace slave {
+
+class OverlayBackendProcess : public Process<OverlayBackendProcess>
+{
+public:
+  Future<Nothing> provision(const vector<string>& layers, const string& rootfs);
+
+  Future<bool> destroy(const string& rootfs);
+};
+
+
+Try<Owned<Backend>> OverlayBackend::create(const Flags&)
+{
+  Result<string> user = os::user();
+  if (!user.isSome()) {
+    return Error("Failed to determine user: " +
+                 (user.isError() ? user.error() : "username not found"));
+  }
+
+  if (user.get() != "root") {
+    return Error("OverlayBackend requires root privileges");
+  }
+
+  return Owned<Backend>(new OverlayBackend(
+      Owned<OverlayBackendProcess>(new OverlayBackendProcess())));
+}
+
+
+OverlayBackend::~OverlayBackend()
+{
+  terminate(process.get());
+  wait(process.get());
+}
+
+
+OverlayBackend::OverlayBackend(Owned<OverlayBackendProcess> _process)
+  : process(_process)
+{
+  spawn(CHECK_NOTNULL(process.get()));
+}
+
+
+Future<Nothing> OverlayBackend::provision(
+    const vector<string>& layers,
+    const string& rootfs)
+{
+  return dispatch(
+      process.get(), &OverlayBackendProcess::provision, layers, rootfs);
+}
+
+
+Future<bool> OverlayBackend::destroy(const string& rootfs)
+{
+  return dispatch(process.get(), &OverlayBackendProcess::destroy, rootfs);
+}
+
+
+Future<Nothing> OverlayBackendProcess::provision(
+    const vector<string>& layers,
+    const string& rootfs)
+{
+  std::ifstream filesystem("/proc/filesystems");
+  std::string line;
+  std::string str("nodev\toverlay");
+  bool overlay_supported = false;
+  while (std::getline(filesystem, line))
+  {
+      if (line.compare(str) == 0) {
+        overlay_supported = true;
+      }
+  }
+
+  if (!overlay_supported) {
+    return Failure("Overlay filesystem not supported");
+  }
+
+  if (layers.size() == 0) {
+    return Failure("No filesystem layer provided");
+  }
+
+  if (layers.size() == 1) {
+    return Failure("Need more than one image for overlay")
+  }
+
+  Try<Nothing> mkdir = os::mkdir(rootfs);
+  if (mkdir.isError()) {
+    return Failure("Failed to create container rootfs at " + rootfs);
+  }
+
+  // The specified lower directories will be stacked beginning from the
+  // rightmost one and going left. The first layer in the vector will be
+  // the bottom most layer (i.e. applied first).
+  std::string lowerDir = "lowerdir=";
+  lowerDir += strings::join(":", layers);
+
+  Try<Nothing> mount = fs::mount(
+      "overlay",
+      mountpoint,
+      "overlay",
+      MS_RDONLY,
+      lowerDir);
+
+  if (mount.isError()) {
+    return Failure("Failed to remount rootfs '" + rootfs + "' read-only: " +
+        mount.error()););
+  }
+
+  return Nothing();
+}
+
+
+Future<bool> OverlayBackendProcess::destroy(const string& rootfs)
+{
+  Try<fs::MountInfoTable> mountTable = fs::MountInfoTable::read();
+
+  if (mountTable.isError()) {
+    return Failure("Failed to read mount table: " + mountTable.error());
+  }
+
+  foreach (const fs::MountInfoTable::Entry& entry, mountTable.get().entries) {
+    if (entry.target == rootfs) {
+      // NOTE: This would fail if the rootfs is still in use.
+      Try<Nothing> unmount = fs::unmount(entry.target);
+      if (unmount.isError()) {
+        return Failure(
+            "Failed to destroy overlay-mounted rootfs '" + rootfs + "': " +
+            unmount.error());
+      }
+
+      Try<Nothing> rmdir = os::rmdir(rootfs);
+      if (rmdir.isError()) {
+        return Failure(
+            "Failed to remove rootfs mount point '" + rootfs + "': " +
+            rmdir.error());
+      }
+
+      return true;
+    }
+  }
+
+  return false;
+}
+
+} // namespace slave {
+} // namespace internal {
+} // namespace mesos {
diff --git a/src/slave/containerizer/provisioner/backends/overlay.hpp b/src/slave/containerizer/provisioner/backends/overlay.hpp
new file mode 100644
index 0000000..dd1d53b
--- /dev/null
+++ b/src/slave/containerizer/provisioner/backends/overlay.hpp
@@ -0,0 +1,65 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef __MESOS_PROVISIONER_OVERLAY_HPP__
+#define __MESOS_PROVISIONER_OVERLAY_HPP__
+
+#include "slave/containerizer/provisioner/backend.hpp"
+
+namespace mesos {
+namespace internal {
+namespace slave {
+
+// Forward declaration.
+class OverlayBackendProcess;
+
+
+// This is a specialized backend that is useful for deploying multi-layer images
+// using the overlayfs-based backend. NOTE:
+// 1) OverlayBackend does not support single images.
+// 2) The filesystem is read-only.
+//    N.B. Since the filesystem is read-only, '--sandbox_directory' must
+//    already exist within the filesystem because the filesystem isolator
+//    is unable to create it!
+class OverlayBackend : public Backend
+{
+public:
+  virtual ~OverlayBackend();
+
+  static Try<process::Owned<Backend>> create(const Flags&);
+
+  virtual process::Future<Nothing> provision(
+      const std::vector<std::string>& layers,
+      const std::string& rootfs);
+
+  virtual process::Future<bool> destroy(const std::string& rootfs);
+
+private:
+  explicit OverlayBackend(process::Owned<OverlayBackendProcess> process);
+
+  OverlayBackend(const OverlayBackend&);
+  OverlayBackend& operator=(const OverlayBackend&);
+
+  process::Owned<OverlayBackendProcess> process;
+};
+
+} // namespace slave {
+} // namespace internal {
+} // namespace mesos {
+
+#endif // __MESOS_PROVISIONER_OVERLAY_HPP__
