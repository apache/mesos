/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __MESOS_SCHEDULER_HPP__
#define __MESOS_SCHEDULER_HPP__

#include <string>
#include <map>
#include <vector>

#include <mesos/mesos.hpp>

/**
 * Mesos scheduler interface and scheduler driver. A scheduler is used
 * to interact with Mesos in order run distributed computations.
 *
 * IF YOU FIND YOURSELF MODIFYING COMMENTS HERE PLEASE CONSIDER MAKING
 * THE SAME MODIFICATIONS FOR OTHER LANGUAGE BINDINGS (e.g., Java:
 * src/java/src/org/apache/mesos, Python: src/python/src, etc.).
*/

namespace mesos {

// A few forward declarations.
class SchedulerDriver;

namespace internal {
class SchedulerProcess;
class MasterDetector;
class Configuration;
}


/**
 * Callback interface to be implemented by frameworks'
 * schedulers. Note that only one callback will be invoked at a time,
 * so it is not recommended that you block within a callback because
 * it may cause a deadlock.
 *
 * Each callback includes a pointer to the scheduler driver that was
 * used to run this scheduler. The pointer will not change for the
 * duration of a scheduler (i.e., from the point you do
 * SchedulerDriver::start() to the point that SchedulerDriver::join()
 * returns). This is intended for convenience so that a scheduler
 * doesn't need to store a pointer to the driver itself.
 */
class Scheduler
{
public:
  /**
   * Empty virtual destructor (necessary to instantiate subclasses).
   */
  virtual ~Scheduler() {}

  /**
   * Invoked when the scheduler successfully registers with a Mesos
   * master. A unique ID (generated by the master) used for
   * distinguishing this framework from others is provided as an
   * argument.
   */
  virtual void registered(SchedulerDriver* driver,
                          const FrameworkID& frameworkId) = 0;

  /**
   * Invoked when resources have been offered to this framework. A
   * single offer will only contain resources from a single slave.
   * Resources associated with an offer will not be re-offered to
   * _this_ framework until either (a) this framework has rejected
   * those resources (see SchedulerDriver::launchTasks) or (b) those
   * resources have been rescinded (see Scheduler::offerRescinded).
   * Note that resources may be concurrently offered to more than one
   * framework at a time (depending on the allocator being used). In
   * that case, the first framework to launch tasks using those
   * resources will be able to use them while the other frameworks
   * will have those resources rescinded (or if a framework has
   * already launched tasks with those resources then those tasks will
   * fail with a TASK_LOST status and a message saying as much).
   */
  virtual void resourceOffers(SchedulerDriver* driver,
                              const std::vector<Offer>& offers) = 0;

  /**
   * Invoked when an offer is no longer valid (e.g., the slave was
   * lost or another framework used resources in the offer). If for
   * whatever reason an offer is never rescinded (e.g., dropped
   * message, failing over framework, etc.), a framwork that attempts
   * to launch tasks using an invalid offer will receive TASK_LOST
   * status updats for those tasks (see Scheduler::resourceOffers).
   */
  virtual void offerRescinded(SchedulerDriver* driver,
                              const OfferID& offerId) = 0;

  /**
   * Invoked when the status of a task has changed (e.g., a slave is
   * lost and so the task is lost, a task finishes and an executor
   * sends a status update saying so, etc). Note that returning from
   * this callback _acknowledges_ receipt of this status update! If
   * for whatever reason the scheduler aborts during this callback (or
   * the process exits) another status update will be delivered (note,
   * however, that this is currently not true if the slave sending the
   * status update is lost/fails during that time).
   */
  virtual void statusUpdate(SchedulerDriver* driver,
                            const TaskStatus& status) = 0;

  /**
   * Invoked when an executor sends a message. These messages are best
   * effort; do not expect a framework message to be retransmitted in
   * any reliable fashion.
   */
  virtual void frameworkMessage(SchedulerDriver* driver,
                                const SlaveID& slaveId,
                                const ExecutorID& executorId,
                                const std::string& data) = 0;

  /**
   * Invoked when a slave has been determined unreachable (e.g.,
   * machine failure, network partition). Most frameworks will need to
   * reschedule any tasks launched on this slave on a new slave.
   */
  virtual void slaveLost(SchedulerDriver* driver,
                         const SlaveID& slaveId) = 0;

  /**
   * Invoked when there is an unrecoverable error in the scheduler or
   * scheduler driver. The driver will be aborted BEFORE invoking this
   * callback. This function is deprecated and will probably be
   * removed in a subsequent release.
   */
  virtual void error(SchedulerDriver* driver,
                     int code,
                     const std::string& message) = 0;
};


/**
 * Abstract interface for connecting a scheduler to Mesos. This
 * interface is used both to manage the scheduler's lifecycle (start
 * it, stop it, or wait for it to finish) and to interact with Mesos
 * (e.g., launch tasks, kill tasks, etc.). See MesosSchedulerDriver
 * below for a concrete example of a SchedulerDriver.
 */
class SchedulerDriver
{
public:
  /**
   * Empty virtual destructor (necessary to instantiate subclasses).
   */
  virtual ~SchedulerDriver() {}

  /**
   * Starts the scheduler driver. This needs to be called before any
   * other driver calls are made.
   */
  virtual Status start() = 0;

  /**
   * Stops the scheduler driver. If the 'failover' flag is set to
   * false then it is expected that this framework will never
   * reconnect to Mesos and all of it's executors and tasks can be
   * terminated. Otherwise, all executors and tasks will remain
   * running (for some master specified failover timeout) allowing the
   * scheduler to reconnect (possibly in the same process, or from a
   * different process, for example, on a different machine).
   */
  virtual Status stop(bool failover = false) = 0;

  /**
   * Aborts the driver so that no more callbacks can be made to the
   * scheduler. The semantics of abort and stop have deliberately been
   * separated so that code can detect an aborted driver (i.e., via
   * the return status of SchedulerDriver::join, see below), and
   * instantiate and start another driver if desired (from within the
   * same process).
   */
  virtual Status abort() = 0;

  /**
   * Waits for the driver to be stopped or aborted, possibly
   * _blocking_ the current thread indefinitely. The return status of
   * this function can be used to determine if the driver was aborted
   * (see mesos.proto for a description of Status).
   */
  virtual Status join() = 0;

  /**
   * Starts and immediately joins (i.e., blocks on) the driver.
   */
  virtual Status run() = 0;

  /**
   * Requests resources from Mesos (see mesos.proto for a description
   * of ResourceRequest and how, for example, to request resources
   * from specific slaves). Any resources available are offered to the
   * framework via Scheduler::resourceOffers callback, asynchronously.
   */
  virtual Status requestResources(
      const std::vector<ResourceRequest>& requests) = 0;

  /**
   * Launches the given set of tasks. Note that the current mechanism
   * of rejecting resources is to invoke this with an empty collection
   * of tasks. A framework can also specify filters on all resources
   * unused (see mesos.proto for a description of Filters). Note that
   * currently tasks can only be launched per offer. In the future,
   * frameworks will be allowed to aggregate offers (resources) to
   * launch their tasks.
   */
  virtual Status launchTasks(const OfferID& offerId,
                             const std::vector<TaskDescription>& tasks,
                             const Filters& filters = Filters()) = 0;

  /**
   * Kills the specified task. Note that attempting to kill a task is
   * currently not reliable. If, for example, a scheduler fails over
   * while it was attempting to kill a task it will need to retry in
   * the future (these semantics may be changed in the future).
   */
  virtual Status killTask(const TaskID& taskId) = 0;

  /**
   * Removes all filters previously set by the framework (via
   * launchTasks()). This enables the framework to receive offers from
   * those filtered slaves.
   */
  virtual Status reviveOffers() = 0;

  /**
   * Sends a message from the framework to one of its executors. These
   * messages are best effort; do not expect a framework message to be
   * retransmitted in any reliable fashion.
   */
  virtual Status sendFrameworkMessage(const SlaveID& slaveId,
                                      const ExecutorID& executorId,
                                      const std::string& data) = 0;
};


/**
 * Concrete implementation of a SchedulerDriver that connects a
 * Scheduler with a Mesos master. The MesosSchedulerDriver is
 * thread-safe.
 *
 * Note that scheduler failover is supported in Mesos. After a
 * scheduler is registered with Mesos it may failover (to a new
 * process on the same machine or across multiple machines) by
 * creating a new driver with the ID given to it in
 * Scheduler::registered.
 *
 * The driver is responsible for invoking the Scheduler callbacks as
 * it communicates with the Mesos master.
 *
 * Note that blocking on the MesosSchedulerDriver (e.g., via
 * MesosSchedulerDriver::join) doesn't affect the scheduler callbacks
 * in anyway because they are handled by a different thread.
 *
 * See src/examples/test_framework.cpp for an example of using the
 * MesosSchedulerDriver.
 */
class MesosSchedulerDriver : public SchedulerDriver
{
public:
  /**
   * Creates a new scheduler driver that connects to a Mesos master
   * through the specified URL. Optionally providing an existing
   * framework ID can be used to failover a framework.
   *
   * Any Mesos configuration options are read from environment
   * variables, as well as any configuration files found through the
   * environment variables.
   */
  MesosSchedulerDriver(Scheduler* sched,
                       const std::string& frameworkName,
                       const ExecutorInfo& executorInfo,
                       const std::string& url,
                       const FrameworkID& frameworkId = FrameworkID());

  /**
   * Creates a new scheduler driver that connects to a Mesos master
   * through a "url" configuration option specified in the 'params'
   * argument. Optionally providing an existing framework ID can be
   * used to failover a framework.
   *
   * Additional Mesos config options are obtained from the 'params'
   * argument.
   */
  MesosSchedulerDriver(Scheduler* sched,
                       const std::string& frameworkName,
                       const ExecutorInfo& executorInfo,
                       const std::map<std::string, std::string>& params,
                       const FrameworkID& frameworkId = FrameworkID());

  /**
   * Creates a new scheduler driver that connects to a Mesos master
   * through a "url" configuration option specified on the
   * command-line (via 'argc' and 'argv'). Optionally providing an
   * existing framework ID can be used to failover a framework.
   */
  MesosSchedulerDriver(Scheduler* sched,
                       const std::string& frameworkName,
                       const ExecutorInfo& executorInfo,
                       int argc,
                       char** argv,
                       const FrameworkID& frameworkId = FrameworkID());

  /**
   * This destructor will block indefinitely if
   * MesosSchedulerDriver::start was invoked successfully (possibly
   * via MesosSchedulerDriver::run) and MesosSchedulerDriver::stop has
   * not been invoked.
   */
  virtual ~MesosSchedulerDriver();

  /**
   * See SchedulerDriver for descriptions of these.
   */
  virtual Status start();
  virtual Status stop(bool failover = false);
  virtual Status abort();
  virtual Status join();
  virtual Status run();
  virtual Status requestResources(
      const std::vector<ResourceRequest>& requests);
  virtual Status launchTasks(
      const OfferID& offerId,
      const std::vector<TaskDescription>& tasks,
      const Filters& filters = Filters());
  virtual Status killTask(const TaskID& taskId);
  virtual Status reviveOffers();
  virtual Status sendFrameworkMessage(
      const SlaveID& slaveId,
      const ExecutorID& executorId,
      const std::string& data);

private:
  // Initialization method used by constructors.
  void init(Scheduler* sched,
            internal::Configuration* conf,
            const FrameworkID& frameworkId,
            const std::string& frameworkName,
            const ExecutorInfo& executorInfo);

  // Internal utility method to report an error to the scheduler.
  void error(int code, const std::string& message);

  Scheduler* sched;
  std::string url;
  FrameworkID frameworkId;
  std::string frameworkName;
  ExecutorInfo executorInfo;

  // Libprocess process for communicating with master.
  internal::SchedulerProcess* process;

  // Coordination between masters
  internal::MasterDetector* detector;

  // Configuration options.
  // TODO(benh|matei): Does this still need to be a pointer?
  internal::Configuration* conf;

  // Mutex to enforce all non-callbacks are execute serially.
  pthread_mutex_t mutex;

  // Condition variable for waiting until driver terminates.
  pthread_cond_t cond;

  enum State {
    INITIALIZED,
    RUNNING,
    STOPPED,
    ABORTED
  };

  // Variable to store the state of the driver.
  State state;
};

} // namespace mesos {

#endif // __MESOS_SCHEDULER_HPP__
